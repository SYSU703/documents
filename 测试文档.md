# 测试文档 

## 整体说明 

本测试文档主要针对后台测试，前端测试主要通过UI测评以及异常（正常）输入进行相关测评处理。前端与后台的交互主要通过postman进行测试，来验证所发送的json格式与内容是否正确。Postman是用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。
Postman下载地址如下：

https://dl.pstmn.io/download

其中支持Mac、Linux和Windows等多种版本。注意，postman是谷歌开发的，所以可以直接在chrome上安装postman的相关插件。
一个前后端接口测试样例（Login功能）如下：

![mahua](/images/postman.png)

## 后台测试 
**①等价类划分** 

把全部输入数据合理地划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据取得较好的测试结果。

有效等价类：指对于软件规格说明而言是合理的、有意义的输入数据的集合。

无效等价类：指对于软件规格说明而言是没有意义的、不合理的输入数据的集合。

等价类划分的原则：
    
（1）在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类.

（2）在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类.

（3）在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类.布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和false。

（4）在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类.

（5）在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）

（6）在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类

  a)为用户注册设计等价类表
   
表1. 测试用户注册的等价类

|         输入          |               有效等价类                | 无效等价类|
| :----------------------: | :------------------------------------: | :---------: |
|         用户名        |    （1）只能为邮箱 <br/>（2）1-45位<br/>（3）和其他已注册用户名不重复                  |      （4）非邮箱地址 <br/> (5）大于45位或为空 <br/>（6）和其他已注册用户名重复      |
|         昵称         |         （7）1-45位        |      （8）大于45位或为空      |
|       密码        |                  （9）1-45位                  |    （10）大于45位或为空    |
|         验证码         |                （13）输入正确验证码                |     （14）输入非正确验证码      |

b)为用户登录设计等价类表。由于登录的用户名和密码与注册有相似之处，故不再赘述相似之处

表2. 测试用户登录的等价类

|         输入          |               有效等价类                | 无效等价类|
| :----------------------: | :------------------------------------: | :---------: |
|         用户名        |    （1）数据库存在该用户名    |      （2）数据库不存在该用户名 |
|         密码         |         （3）数据库存在匹配记录       |      （4）数据库不存在匹配记录<br/>（5）密码存在SQL注入  |


**②边界值分析**

边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法，通常作为对等价类划分法的补充，其测试用例来自等价类的边界。
边界值分析使用与等价类划分法相同的划分，只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。
边界值分析的原则：

（1）如果输入条件规定了值的范围，则应取刚达到这个范围的边界值以及刚刚超过这个范围边界的值作为测试输入数据。

（2）如果输入条件规定了值的个数，则用最大个数、最小个数和比最大个数多1个、比最小个数少1个的数作为测试数据。

（3）根据程序规格说明的每个输出条件，使用原则（1）。

（4）根据程序规格说明的每个输出条件，使用原则（2）。

（5）如果程序的规格说明给出的输入域或输出域是有序集合（如有序表、顺序文件等），则应选取集合中的第一个和最后一个元素作为测试用例。

（6）如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。

（7）分析程序规格说明，找出其它可能的边界条件。

为用户注册分析边界值：

userMAX：用户名最大位数	userMIN：用户名最小位数 userMAX+：比用户名最大位数多一位 userMIN-：比用户名最小位数少一位

nickMAX：昵称最大位数	nickMIN：昵称最小位数 nickMAX+：比昵称最大位数多一位 nickMIN-：比昵称最小位数少一位

pwdMAX：密码最大位数	pwdMIN：密码最小位数 pwdMAX+：比密码最大位数多一位 pwdMIN-：比密码最小位数少一位

verifyCode：用户输入验证码数字   verifyCode+：比4位正确验证码多一位 verifyCode-：比4位正确验证码少一位

**③测试用例设计（基于等价划分类）**

（1）用户注册的测试用例

表3. 用户注册测试用例表

|         条件          |               测试用例               | 预期结果|
| :----------------------: | :------------------------------------: | :---------: |
|         1，2，3，7，9，11，13        |    用户名：2250222@qq.com<br/>昵称：apple<br/>密码：apple<br/>生日：1997-06-21<br/>验证码：正确    |      成功 |
|         1，2，6，7，9，11，13         | 用户名：2250222@qq.com<br/>昵称：bear<br/>密码：bear<br/>生日：1997-06-11<br/>验证码：正确       |      失败（用户名重复）|
|        2，3，4，7，9，11，13         | 用户名：ssbauidkas<br/>昵称：sadae<br/>密码：saesad<br/>生日：1997-06-11<br/>验证码：正确       |      失败（输入的用户名不是正确邮箱形式）|
|       5，7，9，11，13        | 用户名：<br/>昵称：sadae<br/>密码：saesad<br/>生日：1997-06-11<br/>验证码：正确       |      失败(用户名为空或大于45位)|
|     1，2，3，8，9，11，13        | 用户名：2250222@163.com<br/>昵称：<br/>密码：saesad<br/>生日：1997-06-11<br/>验证码：正确       |      失败(昵称为空或大于45位)|
|    1，2，3，7，10，11，13     | 用户名：2250222@163.com<br/>昵称：apple<br/>密码：<br/>生日：1997-06-11<br/>验证码：正确       |      失败(密码为空或大于45位)|
|    1，2，3，7，9，12，13    | 用户名：2250222@163.com<br/>昵称：apple<br/>密码：05643<br/>生日：1997-3211<br/>验证码：正确       |      失败(生日输入不合法)|
|    1，2，3，7，9，11，14    | 用户名：2250222@163.com<br/>昵称：apple<br/>密码：05643<br/>生日：1997-02-11<br/>验证码：错误       |      失败（验证码输入错误） |

（2）用户登录的测试用例

表4. 用户登录测试用例表

|         条件          |               测试用例               | 预期结果|
| :----------------------: | :------------------------------------: | :---------: |
|         （1）数据库存在该用户名<br/>（3）数据库存在匹配记录<br/>（用户名：2250222@qq.com，密码：apple）       |    用户名：2250222@qq.com<br/>密码：apple   |      成功 |
|        （1）数据库存在该用户名<br/>（4）数据库不存在匹配记录<br/>（用户名密码同上）         | 用户名：2250222@qq.com<br/>密码：aaa   |      失败|
|        （1）数据库不存在该用户名<br/>（用户不小心输入错误）<br/>（用户名密码同上）         | 用户名：22502222@qq.com<br/>密码：apple  |      失败|
|       （1）数据库存在该用户名 <br/>（2）密码存在SQL注入<br/>(用户名密码同上）        | 用户名：2250222@qq.com <br/>密码：1' OR '1'='1 （SQL语句被填为“SELECT * FROM users WHERE (uid=2250222@qq.com) AND (password='1' OR '1'='1')”）       |      失败<br/>（注：在实际问题中我们使用了Sharedpreference来防止SQL注入问题）|



**④主要测试代码**

在本软件中我们主要使用输入/输出调试来进行测试，主要测试代码如下（存在于代码文档的main.java中）：
![mahua](/images/testcode1.png)
![mahua](/images/testcode2.png)
![mahua](/images/testcode3.png)
![mahua](/images/testcode4.png)


